#include "Utils.h"

// ===============
// The CUDA kernel
// ===============

__global__ void deviceAddKernel(const float * d_a, const float * d_b, float * d_c, int vSize)
{
	int gIdx = blockIdx.x * blockDim.x + threadIdx.x;

	// Disable the threads which are not needed
	if (gIdx >= vSize)
	{
		return;
	}

	// Active threads will perform the addition
	d_c[gIdx] = d_a[gIdx] + d_b[gIdx];
}

// ===========================================
// Add vectors on the CPU and measure the time
// ===========================================

float hostAdd(const float * h_a, const float * h_b, float * h_c, const int vSize)
{
	long long startMoment;
	float pcFreq;

	hostTimerStart(&pcFreq, &startMoment);

	// The host-based vector addition
	for (int i = 0; i < vSize; ++i)
	{
		h_c[i] = h_a[i] + h_b[i];
	}

	// Return the time in microseconds
	return hostTimerStop(pcFreq, startMoment);
}

// ===========================================
// Add vectors on the GPU and measure the time
// ===========================================

float deviceAdd(const float * h_a, const float * h_b, float * h_c, int vSize,
	int nBlocks, int nThreadsPerBlock)
{
	float * d_a = NULL;	// Input array A on the device
	float * d_b = NULL;	// Input array B on the device
	float * d_c = NULL;	// Output array C on the device
	float time;
	int byteSize = vSize * sizeof(float);
	cudaEvent_t start, stop;

	// Create events for measuring elapsed time on the device
	SAFE_CUDA_CALL(cudaEventCreate(&start));
	SAFE_CUDA_CALL(cudaEventCreate(&stop));

	// Allocate and fill the device-based arrays
	generateDeviceData(byteSize, &d_a, h_a, TRUE);
	generateDeviceData(byteSize, &d_b, h_b, TRUE);
	generateDeviceData(byteSize, &d_c, NULL, FALSE);

	// Record the starting moment of the vector addition
	SAFE_CUDA_CALL(cudaEventRecord(start, 0));

	// Launch the kernel (asynchronously)
	deviceAddKernel<<<nBlocks, nThreadsPerBlock>>>(d_a, d_b, d_c, vSize);

	// Record the ending moment of the vector addition and synchronized
	SAFE_CUDA_CALL(cudaEventRecord(stop, 0));
	SAFE_CUDA_CALL(cudaEventSynchronize(stop));

	// Calculate the elapsed time
	SAFE_CUDA_CALL(cudaEventElapsedTime(&time, start, stop));

	// Transfer the computed array back to the host
	SAFE_CUDA_CALL(cudaMemcpy(h_c, d_c, byteSize, cudaMemcpyDeviceToHost));

	// Free used resources on the device
	SAFE_CUDA_CALL(cudaFree(d_a));
	SAFE_CUDA_CALL(cudaFree(d_b));
	SAFE_CUDA_CALL(cudaFree(d_c));
	SAFE_CUDA_CALL(cudaEventDestroy(start));
	SAFE_CUDA_CALL(cudaEventDestroy(stop));

	return time * 1.0E+3F;
}

// =======================
// Application entry point
// =======================

int _02_Vector_Add(int argCount, char ** argValues)
{
	int vGridConf[3];	// The grid configuration
	float * h_a = NULL;		// Host input array A
	float * h_b = NULL;		// Host input array B
	float * h_c_h = NULL;	// Host output array C as generated by the host
	float * h_c_d = NULL;	// Host output array C as generated by the device
	float hostTime, devTime;
	const char * vErrMessages[2] =	{"Error: The number of threads must be greater than 0.",
									 "Error: The array size must be greater than 0."};

	// Validate the command-line arguments
	validateArguments(argCount, 2, argValues, vGridConf, vErrMessages);

	// Generate the host-based data
	generateHostData(vGridConf[2], &h_a, TRUE);		// Input array A
	generateHostData(vGridConf[2], &h_b, TRUE);		// Input array B
	generateHostData(vGridConf[2], &h_c_h, FALSE);	// Output host array C generated by the host		
	generateHostData(vGridConf[2], &h_c_d, FALSE);	// Output host array C generated by the device

	printf("Data generation complete." NEW_LINE);

	// Perform the host-based addition
	hostTime = hostAdd(h_a, h_b, h_c_h, vGridConf[2]);

	printf("Host addition time: %.2f us" NEW_LINE, hostTime);
	printf("Will launch (B: %d, T: %d, G: %d):" NEW_LINE, vGridConf[0], vGridConf[1], vGridConf[2]);

	// Perfrm the device-based addition
	devTime = deviceAdd(h_a, h_b, h_c_d, vGridConf[2], vGridConf[0], vGridConf[1]);

	printf("Device addition time: %.2f us" NEW_LINE, devTime);

	// Compute the speed-up between the device and the host
	printf("Speed-up: %.2f" NEW_LINE, hostTime / devTime);

	// Check if the calculated arrays match
	compareResults(h_c_h, h_c_d, vGridConf[2]);

	// Free host memory
	free(h_a);
	free(h_b);
	free(h_c_h);
	free(h_c_d);
	
	WAIT_AND_EXIT(0);
}